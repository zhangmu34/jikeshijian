# 第一题

## 请你用自己的语言介绍 Java 运行时数据区（内存区域）

### 1.**堆、虚拟机栈、本地方法栈、方法区（永久代、元空间）、运行时常量池（字符串常量池）、直接内存**

可以分为线程独有和线程间共享两个部分：

### ***线程独有***

虚拟机栈、本地方法栈、程序计数器

#### 虚拟机栈

主管java程序的运行，管理java方法的调用，每有一个线程创建就会有一个虚拟机栈，每有一个需要执行的方法，就会生成一个对应栈帧，栈帧里有

局部变量表（8种基本数据类型、对象的引用地址（new的对象都在堆））、操作栈、动态链接、返回地址。执行引擎只会执行栈顶的元素，叫当前栈帧

#### 本地方法栈

管理java本地方法的调用，和虚拟机栈类似，里面的方法都是native关键字修饰的非java语言编写的接口，主要和操作系统还有硬件打交道



### ***线程间共享***

方法区（永久代、元空间）、堆、运行时常量池（字符串常量池）、直接内存

#### 直接内存

直接内存就是jvm虚拟机内存外的物理内存，不受到jvm堆大小的影响

#### 堆

存储类对象、数组、运行时常量，所占内存是最大的。大部分虚拟机遵循分代收集理论设计的垃圾收集器，所以堆空间细分为新生代和老年代，新生代因为垃圾算法又分为一个eden区和两个Survivor区。jdk1.7之前还存在一个永久代保存一些类的信息，jdk1.8之后永久代变成元空间，放在直接内存里

#### 方法区（永久代、元空间）

存放类型信息、运行时常量池（字符串常量池）、JIT编译器编译之后的代码缓存，具体有哪些可以javap -v -p查看，在classloader把class文件加载到内存中的时候，相应的信息就放在方法区中，还保留了是什么类加载器加载的信息。代码里new的对象是哪个类new的，指向的就是方法区的对象的类型信息。

根据jdk版本的不同，方法区也有不同的变化，1.7版本还存在永久代，但是方法区里的运行时常量池（字符串常量池）已经放在堆中，1.8版本已经没有永久代，变成了元空间，并且放在jvm进程之外的直接内存

#### 运行时常量池（字符串常量池）

.class文件里有常量池，加载到方法区以后就是运行时常量池。字符串常量池，全局只有一个字符串常量池，是双引号引起来的字符串值，编译期就存储在堆中，new出来的不会进字符串常量池，直接进堆。

字符串常量池本质是一个hashtable，hashtable是个数组，如果hash冲突，就会在对用数组下标创建一个链表，存储hash值一样的数据，读取的时候用equals比对





# 第二题 

## 描述一个 Java 对象的生命周期

#### 解释一个对象的创建过程

new一个对象，先在运行时常量池能不能找到符号引用，有引用的话是否被加载，没有就通过类加载器加载，然后分配内存空间（根据GC不同分为指针碰撞、空闲列表。所有属性设置默认值。），必要信息设置（对象头），初始化完成

#### 解释一个对象的内存分配

创建对象的时候在加载的时候会计算对象占用空间大小，堆中划分一块内存给新对象，根据GC选择的不同分配方式分为指针碰撞（内存规整）、空闲列表（内存不规整），分配内存会有内存安全问题，主流的是先从TLAB分，不够的话再用cas从堆里分

#### 解释一个对象的销毁过程

当方法执行完，没有引用的对象称为垃圾，会用引用计数法和根可达算法（GCRoots）来找到垃圾，然后等待GC的回收，回收的时候有两次标记，两次标记成功的会被回收

#### 对象的两种访问方式

这个不知道，好像没有讲

#### 为什么要内存担保

当一个大对象放不进新生代的时候，需要把新生代里的对象移到老年代，腾空新生代，放入大对象，如果腾空新生代也放不下，直接放入老年代



# 第三题

## 垃圾收集算法有哪些？垃圾收集器有哪些？他们的特点是什么？

#### 垃圾收集算法有哪些

JVM提供3种方法，清除垃圾对象：Mark-Sweep 标记清除算法、Copying 拷贝算法、Mark-Compact 标记压缩算法

新生代用拷贝算法，老年代使用标记清除算法或标记压缩算法。

#### 垃圾收集器有哪些

8种

新生代回收器：Serial、ParNew、Parallel Scavenge

老年代回收器：Serial Old、Parallel Old、CMS

整堆回收器：G1、ZGC

#### 他们的特点是什么

串行收集器：Serial新生代（单线程执行，使用复制算法）、Serial Old老年代（单线程收集器，使用“标记-整理”算法）。进行垃圾收集时，必须暂停其他所有的工作线程。

并行收集器：Parallel Scavenge新生代（使用并行回收收集器，采用复制算法）、ParNew新生代（相比Parallel Scavenge可以设置并行线程数，使用并行回收收集器，采用复制算法）、Parallel Old老年代（使用多线程和“标记-整理”算法）、CMS（并发回收，标记-清除算法）

整堆回收：G1，ZGC

