# 题目 01- 一条 SQL 语句在 MySQL 中是如何执行的？

第一步：连接到数据库 

通过命令连接 mysql  -uroot -p，show processlist;可以查看连接状态

第二步：查缓存

有查询缓存，直接返回，没有走下一步，mysql8.0删除了这部分

第三步：分析SQL语句

词法解析、语法分析、预处理器 判断sql语句是否正确可执行，生成新的解析树

第四步：优化SQL语句

根据解析树选择最优执行计划，比如使用什么索引，覆盖索引等

第五步：执行SQL语句

首先会判断有没有查询权限，有的话继续执行，调用存储引擎接口

第六步：调用接口从存储引擎存取数据

# 题目 02- 请解释一下你理解的事务是什么？

事务指的是一个整体的操作，这个整体里的所有操作要么全都成功，要么全都失败。

**事务四大特性 ACID**

原子性（Atomicity）： 原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，
要么都不发生。
一致性（Consistency）： 事务前后数据的完整性必须保持一致
隔离性（Isolation）：多个用户并发访问数据库时，一个用户的事务不能被其它用户的事务所干
扰，多个并发事务之间数据要相互隔离。
持久性（Durability）： 一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即
使数据库发生故障也不应该对其有任何影响。

**事务会产生的并发问题**

读

1.脏读：一个事务读到了另一个事务未提交的数据

2.不可重复读：一个事务读到了另一个事务已经提交(update)的数据。引发事务中的多次查询结果不一致

3.虚读 /幻读：一个事务读到了另一个事务已经插入(insert)的数据。导致事务中多次查询的结果不一致

写

4.丢失更新的问题

**事务隔离级别**

read uncommitted 读未提交【RU】，一个事务读到另一个事务没有提交的数据
存在：3个问题（脏读、不可重复读、幻读）。
read committed 读已提交【RC】，一个事务读到另一个事务已经提交的数据
存在：2个问题（不可重复读、幻读）。
解决：1个问题（脏读）
repeatable read:可重复读【RR】，在一个事务中读到的数据始终保持一致，无论另一个事务是
否提交
解决：3个问题（脏读、不可重复读、幻读）
serializable 串行化，同时只能执行一个事务，相当于事务中的单线程
解决：3个问题（脏读、不可重复读、幻读）

**事务的安全性、性能与隔离级别的关系**

**安全性**

serializable 串行化 **>** repeatable read 可重复读 **>** read committed 读已提交 **>** read uncommitted 读未提交

**性能**

serializable 串行化 **<** repeatable read 可重复读 **<** read committed 读已提交 **<** read uncommitted 读未提交

